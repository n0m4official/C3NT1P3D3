#include "VulnerabilityDatabase.h"
#include <fstream>
#include <algorithm>
#include <sstream>

namespace C3NT1P3D3 {

std::unique_ptr<VulnerabilityDatabase> VulnerabilityDatabase::instance = nullptr;

VulnerabilityDatabase& VulnerabilityDatabase::getInstance() {
    if (!instance) {
        instance = std::unique_ptr<VulnerabilityDatabase>(new VulnerabilityDatabase());
    }
    return *instance;
}

VulnerabilityDatabase::VulnerabilityDatabase() {
    loadBuiltInVulnerabilities();
}

VulnerabilityDatabase::~VulnerabilityDatabase() = default;

void VulnerabilityDatabase::loadBuiltInVulnerabilities() {
    // SQL Injection vulnerabilities
    vulnerabilities["CVE-2023-XXXX"] = {
        "CVE-2023-XXXX",
        "Generic SQL Injection",
        "SQL injection vulnerability allowing unauthorized database access",
        VulnerabilityType::SQL_INJECTION,
        Severity::HIGH,
        {"All versions"},
        "(' OR '1'='1",
        "Use parameterized queries and input validation",
        std::chrono::system_clock::now(),
        std::chrono::system_clock::now(),
        8.1,
        {"https://owasp.org/www-community/attacks/SQL_Injection"}
    };
    
    // Update the type and severity maps
    for (const auto& [cve_id, vuln] : vulnerabilities) {
        vulnerabilities_by_type[vuln.type].push_back(cve_id);
        vulnerabilities_by_severity[vuln.severity].push_back(cve_id);
    }
}

void VulnerabilityDatabase::loadDatabase() {
    loadBuiltInVulnerabilities();
}

void VulnerabilityDatabase::updateDatabase() {
    loadBuiltInVulnerabilities();
}

std::vector<VulnerabilitySignature> VulnerabilityDatabase::getVulnerabilitiesByType(VulnerabilityType type) const {
    std::vector<VulnerabilitySignature> result;
    
    auto it = vulnerabilities_by_type.find(type);
    if (it != vulnerabilities_by_type.end()) {
        for (const auto& cve_id : it->second) {
            auto vuln_it = vulnerabilities.find(cve_id);
            if (vuln_it != vulnerabilities.end()) {
                result.push_back(vuln_it->second);
            }
        }
    }
    
    return result;
}

std::vector<VulnerabilitySignature> VulnerabilityDatabase::getVulnerabilitiesBySeverity(Severity severity) const {
    std::vector<VulnerabilitySignature> result;
    
    auto it = vulnerabilities_by_severity.find(severity);
    if (it != vulnerabilities_by_severity.end()) {
        for (const auto& cve_id : it->second) {
            auto vuln_it = vulnerabilities.find(cve_id);
            if (vuln_it != vulnerabilities.end()) {
                result.push_back(vuln_it->second);
            }
        }
    }
    
    return result;
}

VulnerabilitySignature VulnerabilityDatabase::getVulnerabilityByCVE(const std::string& cve_id) const {
    auto it = vulnerabilities.find(cve_id);
    if (it != vulnerabilities.end()) {
        return it->second;
    }
    
    // Return a default vulnerability if not found
    return {
        "UNKNOWN",
        "Unknown Vulnerability",
        "Vulnerability not found in database",
        VulnerabilityType::ZERODAY_WEB,
        Severity::MEDIUM,
        {"Unknown"},
        "",
        "Apply security patches and follow security best practices",
        std::chrono::system_clock::now(),
        std::chrono::system_clock::now(),
        5.0,
        {}
    };
}

bool VulnerabilityDatabase::isVulnerabilityKnown(const std::string& cve_id) const {
    return vulnerabilities.find(cve_id) != vulnerabilities.end();
}

void VulnerabilityDatabase::addCustomVulnerability(const VulnerabilitySignature& vuln) {
    vulnerabilities[vuln.cve_id] = vuln;
    vulnerabilities_by_type[vuln.type].push_back(vuln.cve_id);
    vulnerabilities_by_severity[vuln.severity].push_back(vuln.cve_id);
}

size_t VulnerabilityDatabase::getTotalVulnerabilities() const {
    return vulnerabilities.size();
}

size_t VulnerabilityDatabase::getVulnerabilitiesByTypeCount(VulnerabilityType type) const {
    auto it = vulnerabilities_by_type.find(type);
    return (it != vulnerabilities_by_type.end()) ? it->second.size() : 0;
}

} // namespace C3NT1P3D3